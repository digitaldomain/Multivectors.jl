# Copyright 2020 Digital Domain 3.0
#
# Licensed under the Apache License, Version 2.0 (the "Apache License")
# with the following modification; you may not use this file except in
# compliance with the Apache License and the following modification to it:
# Section 6. Trademarks. is deleted and replaced with:
#
# 6. Trademarks. This License does not grant permission to use the trade
#    names, trademarks, service marks, or product names of the Licensor
#    and its affiliates, except as required to comply with Section 4(c) of
#    the License and to reproduce the content of the NOTICE file.
#
# You may obtain a copy of the Apache License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the Apache License with the above modification is
# distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied. See the Apache License for the specific
# language governing permissions and limitations under the Apache License.

using Test
using Multivectors
using KVectors
using Blades
using LinearAlgebra


module PG2
  using Blades, KVectors, Multivectors, LinearAlgebra
  @generate_basis("++0")

  const e‚Çí_index = 3
  const e‚Çí = e‚ÇÉ
  const e‚ÇÇ‚Çí = e‚ÇÇ‚ÇÉ
  const e‚ÇÅ‚Çí = e‚ÇÅ‚ÇÉ

  meet(a, b) = a‚àßb
  point(x::Real, y::Real) = x*e‚ÇÇ‚Çí + y*e‚ÇÅ‚Çí + one(x)*e‚ÇÅ‚ÇÇ
  direction(x::Real, y::Real) = x*e‚ÇÇ‚Çí + y*e‚ÇÅ‚Çí
  point( v::KVector{T} ) where T = point(coords(v)[1:2]...)
  line(a,b) = a‚à®b

  """ project point to euclidean (1e‚Çí) plane """ 
  projr(a) = a/(dual(1.0e‚ÇÉ)‚ãÖa)

  function circumcentre( a, b, c )
    ab = line(a, b)
    bc = line(b, c)
    ab_mid = 0.5*(a+b)
    bc_mid = 0.5*(b+c)
    abperp = ab‚ãÖab_mid
    bcperp = bc‚ãÖbc_mid

    projr(abperp‚àßbcperp) 
  end
  
end

using .PG2
@testset "PG2" begin
  @test PG2.circumcentre( PG2.point(0.0, 0.0), PG2.point(1.0,0.0), PG2.point(0.0,1.0) ) == PG2.point(0.5, 0.5)
end

module HomogeneousG2
  using Blades, KVectors, Multivectors, LinearAlgebra
  @generate_basis("+++")

  const e‚Çí_index = 3
  const e‚Çí = e‚ÇÉ

  ishomog( v::KVector{T} ) where T = filter(x->x==e‚Çí_index, subspace.(v)) |> isempty
  point( a, b ) = a*e‚ÇÅ+b*e‚ÇÇ + one(a)*e‚ÇÉ
  point( v::KVector{T} ) where T = ishomog(v) ? v : v + one(T)e‚Çí
  line( p, q ) = p‚àßq
  plane( p, q, r ) = p‚àßq‚àßr
  unitize( p::KVector{T} ) where T = (Œ± = one(T)e‚Çí‚ãÖp; iszero(Œ±) ? p : p*inv(alpha))  

  function meet(a, b)
    J = inv(1.0e‚ÇÅ‚ÇÇ‚ÇÉ)
    ((a*J)‚àß(b*J))*J
  end

  """ project to euclidean (1e‚Çí) plane """ 
  projr(a) = a/norm(1.0e‚Çí‚ãÖa)

  function circumcentre( a, b, c )
    mid_ab = 0.5*(a+b)
    mid_bc = 0.5*(b+c)
    ab = (a‚àßb)
    bc = (b‚àßc)
    rab = 1.0e‚Çí‚ãÖab
    rbc = 1.0e‚Çí‚ãÖbc
    tri = rab‚àßrbc
    abperp = rab*inv(tri)
    bcperp = rbc*inv(tri)
    centre_ab = mid_ab‚àßabperp
    centre_bc = mid_bc‚àßbcperp
    meet(centre_ab, centre_bc)
  end
end

using .HomogeneousG2
@testset "HomogeneousG2" begin
  pointh = HomogeneousG2.point
  @test HomogeneousG2.circumcentre( pointh(0.0, 0.0), pointh(1.0,0.0), pointh(0.0,1.0) ) == pointh(0.5, 0.5)
end

module CGA
  using Blades, KVectors, LinearAlgebra
  
  @generate_basis("++++-",false,true)
  const eo = 0.5*(1.0e‚ÇÑ + 1.0e‚ÇÖ)
  const e‚àû = 1.0e‚ÇÖ-1.0e‚ÇÑ

  point( p::K ) where {T, K<:Union{KVector{T,1}, Blade{T,1}}} = one(T)*eo + p + (one(T)/2)*p*p*e‚àû
  locate( a, M ) = (a‚ãÖM)/M
  circumcentre( a, b, c) = locate(a, (a‚àßb + b‚àßc + c‚àßa)/(a‚àßb‚àßc‚àße‚àû))
end

using .CGA

@testset "CGA3D" begin
  e‚ÇÅ, e‚ÇÇ, e‚ÇÉ = alle( CGA, 5 )[1:3]
  using .CGA: eo, e‚àû, point, circumcentre
  @test e‚àû‚ãÖe‚àû == 0
  @test eo‚ãÖe‚àû == -1.0

  # test circumcentre of triangle
  
  a = point(0.0e‚ÇÅ+0.0e‚ÇÇ)
  b = point(1.0e‚ÇÅ)
  c = point(1.0e‚ÇÇ)

  C = (a‚àßb + b‚àßc + c‚àßa)/(a‚àßb‚àßc‚àße‚àû)
  ccentre = (a‚ãÖC)/C
  @test coords(grade(ccentre,1))[1:2] == [0.5,0.5]
  a = point(0.0e‚ÇÅ+0.0e‚ÇÇ)
  b = point(1.0e‚ÇÅ)
  c = point((sqrt(3.0)/2.0)e‚ÇÇ)
  ccentre = grade(circumcentre(a,b,c), 1) 

  @test norm(ccentre - grade(a,1)) ‚âà norm(ccentre - grade(b,1)) ‚âà norm(ccentre - grade(c,1))
end

module PG3
  using Blades
  @generate_basis("+++0")
end
using .PG3
@testset "PGA3D" begin
  e‚ÇÅ, e‚ÇÇ, e‚ÇÉ, e‚ÇÑ = alle( PG3, 4)[1:4]
  e‚ÇÅ‚ÇÇ = PG3.e‚ÇÅ‚ÇÇ; e‚ÇÉ‚ÇÑ = PG3.e‚ÇÉ‚ÇÑ; e‚ÇÅ‚ÇÇ‚ÇÉ‚ÇÑ = PG3.e‚ÇÅ‚ÇÇ‚ÇÉ‚ÇÑ;
  a = e‚ÇÅ(1.0); b = e‚ÇÇ(2.0); c = e‚ÇÉ(3.0); d = e‚ÇÑ(4.0)
  @test typeof(a+b*c) == typeof(Multivector{Float64,2}())
  B1 = KVector(a)
  B2 = a*b + b*c
  B3 = a*b*c + b*c*d
  B4 = KVector(a*b*c*d)
  M13 = B1+B3
  @test grade(M13) == 3
  @test grades(M13) == [1,3]
  @test grade(M13, 2) == 0.0
  @test grade(M13, 1) == B1
  @test grade(M13, 3) == B3
  @test grade(M13, 0) == 0.0
  M013 = M13+42.0
  @test grade(M013, 0) == 42.0
  B = a+b
  @test B*B == a*a+a*b+b*a+b*b
  @test grade((2e‚ÇÇ+3e‚ÇÉ)*(2e‚ÇÇ+3e‚ÇÉ), 0) == 2*2+3*3

  A = 2e‚ÇÉ +3e‚ÇÇ
  B = 5e‚ÇÑ+6e‚ÇÉ
  # if we had an e‚ÇÅ (degen metric) component this would not be true.
  @test A‚ãÖ!B == !(A‚àßB)
  
  A‚ÇÄ = 2e‚ÇÅ + 3e‚ÇÇ
  B‚ÇÄ = 5e‚ÇÅ + 6e‚ÇÉ

  # interesting though, this is ok.  
  ùêº = 1e‚ÇÅ‚ÇÇ‚ÇÉ‚ÇÑ 
  @test A‚ÇÄ‚ãÖ(B‚ÇÄ‚ãÖùêº) == (A‚ÇÄ‚àßB‚ÇÄ)‚ãÖùêº == (A‚ÇÄ‚àßB‚ÇÄ)*ùêº == A‚ÇÄ‚ãÖ(B‚ÇÄ*ùêº)# == A‚ÇÄ‚ãÖ(B‚ÇÄ*dual(1))

  C = 1e‚ÇÅ‚ÇÇ+4e‚ÇÉ‚ÇÑ
  @test (A‚àßB)‚ãÖC == A‚ãÖ(B‚ãÖC)

  # inner product tests
  # conjugate symmetry? a property an innerproduct is supposed to have.  probably not
  #  @test A‚ãÖC == conj(C‚ãÖA)
  # linearity in first argument 
  @test (A+B)‚ãÖC == (A‚ãÖC)+(B‚ãÖC) 

  @test 2*A√óB == (A*B-B*A)
  A = 2-A
  B = 2*B + 3(e‚ÇÇ‚àße‚ÇÉ)
  @test 2A√óB == (A*B-B*A)
end

module G4
  using Blades
  @generate_basis("++++")
end
using .G4
@testset "contraction" begin

  e‚ÇÅ, e‚ÇÇ, e‚ÇÉ, e‚ÇÑ  = alle( G4, 4)[1:4]

  rand1() = rand(1)[1]
  a = rand1()‚àße‚ÇÅ + rand()‚àße‚ÇÉ
  # test lcontraction result is orthogonal to original
  B = rand()*(e‚ÇÅ‚àße‚ÇÇ)
  @test a‚ãÖ(a‚ãÖB) == 0.0
  B = B + rand()*(e‚ÇÉ‚àße‚ÇÑ)
  @test a‚ãÖ(a‚ãÖB) == 0.0
  

  A = 1.0 + 3.0G4.e‚ÇÅ‚ÇÉ
  @test lcontraction(a,A) == a‚ãÖA
  @test rcontraction(A,a) == (A*a)[grade(A)-grade(a)]
  @test grades(A) == [0,2]
  show(A)
  @test first(A) == 1.0
  @test [i for i in A] == map(i->i, A) |>collect == (i for i in A) |> collect 
  @test length(A) == 2
  @test mapreduce(identity, +, A) == A
  @test mapreduce(conj, +, A) == conj(A)
  @test 1.0e‚ÇÅ + A[2] + A[0] == A + 1.0e‚ÇÅ 
  @test iszero(grade(A,10))
  @test grades(1.0) == [0]
  @test grade(1.0, 0) == 1.0
  @test grade(1.0, 1) == 0.0
  @test grades(A[2]) == [2]
  @test prune(dual(A)*pseudoscalar(A[2])) == A
  @test A/2.0 == A*0.5 
  @test A[2] == A-A[0]
  @test mapreduce(LinearAlgebra.norm_sqr, +, A) == scalarprod(A,reverse(A)) == 10.0
  @test normalize(A) == A/sqrt(scalarprod(A,reverse(A)))

  for i in A
    show(i)
  end

end

module G3
  using Blades
  @generate_basis("+++",false,true,true)
end
using .G3
@testset "Quaternion" begin

  e‚ÇÅ, e‚ÇÇ, e‚ÇÉ, e‚ÇÅ‚ÇÇ, e‚ÇÅ‚ÇÉ, e‚ÇÇ‚ÇÉ, e‚ÇÅ‚ÇÇ‚ÇÉ = alle( G3, 3)
#==
  Quaternion multiplication
√ó	i	j	k
i	‚àí1	k	‚àíj
j	‚àík	‚àí1	i
k	j	‚àíi	‚àí1
==#

  # quaternion basis
  ùëñ = e‚ÇÇ‚ÇÉ; ùëó = e‚ÇÅ‚ÇÉ; ùëò = e‚ÇÅ‚ÇÇ
  @test 1ùëñ*1ùëó*1ùëò == -1

  @test (1ùëñ*1ùëñ, 1ùëñ*1ùëó, 1ùëñ*1ùëò) == (-1, 1ùëò, -1ùëó)
  @test (1ùëó*1ùëñ, 1ùëó*1ùëó, 1ùëó*1ùëò) == (-1ùëò, -1, 1ùëñ)
  @test (1ùëò*1ùëñ, 1ùëò*1ùëó, 1ùëò*1ùëò) == (1ùëó, -1ùëñ, -1)

  ùëñ = e‚ÇÅ‚ÇÇ; ùëó = e‚ÇÇ‚ÇÉ; ùëò = e‚ÇÅ‚ÇÉ
  @test 1ùëñ*1ùëó*1ùëò == -1
  @test (1ùëñ*1ùëñ, 1ùëñ*1ùëó, 1ùëñ*1ùëò) == (-1, 1ùëò, -1ùëó)
  @test (1ùëó*1ùëñ, 1ùëó*1ùëó, 1ùëó*1ùëò) == (-1ùëò, -1, 1ùëñ)
  @test (1ùëò*1ùëñ, 1ùëò*1ùëó, 1ùëò*1ùëò) == (1ùëó, -1ùëñ, -1)


  half45 = normalize(1.0e‚ÇÅ + normalize(1.0e‚ÇÅ+1.0e‚ÇÇ))
  q = half45/1.0e‚ÇÅ

  # Transform a 1-vector with the sandwich product.
  v = reverse(q)*(1.0e‚ÇÅ+1.0e‚ÇÇ+1.0e‚ÇÉ)*q

  v‚Ä≤ = grade(v, 1) |> prune‚àòsortbasis
  @test v‚Ä≤‚ãÖ1.0e‚ÇÉ == 1.0
  @test v‚Ä≤‚ãÖ1.0e‚ÇÅ ‚âà sqrt(2.0)

  # Rotors can be constructed using half-angle of trig functions, like quaternions.

  @test cos(œÄ/8) - sin(œÄ/8)*1.0e‚ÇÅ‚ÇÇ == q

end

@testset "Barycentric" begin

  e‚ÇÅ, e‚ÇÇ, e‚ÇÉ  = alle( G3, 3)[1:3]

  a = 0.0e‚ÇÅ+0.0e‚ÇÇ; b = 1.0e‚ÇÅ + 0.0e‚ÇÇ; c = 0.0e‚ÇÅ + 1.0e‚ÇÇ;  # a simple right angle triangle

  A = (b-a)‚àß(c-a)  # twice the area of the triangle. we don't worry about the factor of 2

  # Make a function to calculate barycentric coords as the ratio of the area of a triangle made with a point `p` and an edge over original triangle.  i.e. the barycentric coord for vertex `a` is the ratio Œîpbc/Œîabc

  barycoords(p) = ((c-b)‚àß(p-b)/A, (a-c)‚àß(p-c)/A, (b-a)‚àß(p-a)/A)  # a tuple of coords

  # Notice how the code very directly represents the geometric relationship.  The body of the function is also coordinate free ( we never index into the points or vertices ).

  @test barycoords(0.0e‚ÇÅ)[1] == 1.0
  @test barycoords(1.0e‚ÇÅ)[2] == 1.0
  @test barycoords(0.5e‚ÇÅ+0.5e‚ÇÇ) == (0.0, 0.5, 0.5)

  baryscalars(p) = map(k->grade(k, 0), barycoords(p))

  @test baryscalars(0.1e‚ÇÅ+0.25e‚ÇÇ+10.0e‚ÇÉ) == (0.65, 0.1, 0.25)
  @test baryscalars(1.0e‚ÇÅ) == (0.0, 1.0, 0.0)

  d = 1.0e‚ÇÉ
  V = A‚àßd

  # tetrahedron
  barycoords4(p) = ((c-b)‚àß(p-b)‚àß(d-c)/V, 
                    (a-c)‚àß(p-c)‚àß(d-a)/V, 
                    (b-a)‚àß(p-a)‚àß(d-a)/V, 
                    (b-a)‚àß(p-a)‚àß(a-c)/V)

  @test barycoords4(0.25e‚ÇÅ+0.25e‚ÇÇ+0.25e‚ÇÉ) == (0.25, 0.25, 0.25, 0.25)
end

